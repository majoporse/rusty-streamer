/* tslint:disable */
/* eslint-disable */
/**
 * Backend For Frontend API
 * API documentation for the BFF service.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface MovieCrewDetail {
    'billing_order'?: number | null;
    'character_name'?: string | null;
    'movie_id': string;
    'person': WrapperPerson;
    'person_id': string;
}
export interface NewUser {
    'bio'?: string | null;
    'email': string;
    'password_hash': string;
    'profile_picture_url'?: string | null;
    'username': string;
}
export interface NewWatchHistory {
    'completed'?: boolean | null;
    'content_id': string;
    'progress_seconds'?: number | null;
    'user_id': string;
}
export interface NewWatchRoom {
    'content_id': string;
    'host_user_id': string;
    'invite_code'?: string | null;
    'is_private'?: boolean | null;
    'room_name'?: string | null;
}
export interface NewWatchRoomMessage {
    'is_system_message'?: boolean | null;
    'message': string;
    'room_id': string;
    'user_id'?: string | null;
}
export interface NewWatchRoomParticipant {
    'is_admin': boolean;
    'room_id': string;
    'user_id': string;
}
export interface NewWatchlist {
    'content_id': string;
    'user_id': string;
}
export interface UpdateUser {
    'bio'?: string | null;
    'email'?: string | null;
    'profile_picture_url'?: string | null;
    'username'?: string | null;
}
export interface UpdateWatchHistory {
    'completed'?: boolean | null;
    'progress_seconds'?: number | null;
}
export interface UpdateWatchRoom {
    'current_time_seconds'?: number | null;
    'is_live'?: boolean | null;
}
export interface UploadSasRequest {
    /**
     * MIME content type
     */
    'content_type'?: string | null;
    /**
     * original filename (including extension)
     */
    'filename': string;
    /**
     * kind of upload, e.g. \"video\" or \"poster\"
     */
    'kind'?: string | null;
}
export interface UploadSasResponse {
    /**
     * canonical blob URL (without SAS) for later reference
     */
    'blob_url': string;
    /**
     * optional expiration timestamp for the upload URL
     */
    'expires_at'?: string | null;
    /**
     * full URL suitable for uploading (may include SAS token)
     */
    'upload_url': string;
}
export interface User {
    'bio'?: string | null;
    'created_at': string;
    'email': string;
    'id': string;
    'last_login_at'?: string | null;
    'password_hash': string;
    'profile_picture_url'?: string | null;
    'status'?: string | null;
    'updated_at': string;
    'username': string;
}
export interface WatchHistory {
    'completed'?: boolean | null;
    'content_id': string;
    'id': number;
    'last_watched_at'?: string | null;
    'progress_seconds'?: number | null;
    'user_id': string;
}
export interface WatchRoom {
    'content_id': string;
    'created_at': string;
    'current_time_seconds'?: number | null;
    'host_user_id': string;
    'id': string;
    'invite_code'?: string | null;
    'is_live'?: boolean | null;
    'is_private': boolean;
    'room_name'?: string | null;
    'updated_at': string;
}
export interface WatchRoomMessage {
    'id': number;
    'is_system_message'?: boolean | null;
    'message': string;
    'room_id': string;
    'sent_at': string;
    'user_id'?: string | null;
}
export interface WatchRoomParticipant {
    'id': number;
    'is_admin': boolean;
    'joined_at'?: string | null;
    'last_active_at'?: string | null;
    'room_id': string;
    'user_id': string;
}
export interface Watchlist {
    'content_id': string;
    'created_at': string;
    'id': number;
    'user_id': string;
}
export interface WrapperGenre {
    'id': string;
    'name': string;
}
export interface WrapperMovie {
    'created_at': string;
    'description'?: string | null;
    'duration_minutes'?: number | null;
    'id': string;
    'mpaa_rating'?: string | null;
    'poster_url'?: string | null;
    'release_date'?: string | null;
    'title': string;
    'updated_at': string;
    'video_url'?: string | null;
}
export interface WrapperMovieCrew {
    'billing_order'?: number | null;
    'person_id': string;
    'role'?: string | null;
}
export interface WrapperMovieDetail {
    'created_at': string;
    'description'?: string | null;
    'duration_minutes'?: number | null;
    'genres': Array<WrapperGenre>;
    'id': string;
    'mpaa_rating'?: string | null;
    'people': Array<MovieCrewDetail>;
    'poster_url'?: string | null;
    'release_date'?: string | null;
    'reviews': Array<WrapperReview>;
    'title': string;
    'updated_at': string;
    'video_url'?: string | null;
}
export interface WrapperNewGenre {
    'name': string;
}
export interface WrapperNewMovie {
    'description'?: string | null;
    'duration_minutes'?: number | null;
    'genre_ids'?: Array<string> | null;
    'mpaa_rating'?: string | null;
    'people_ids'?: Array<WrapperMovieCrew> | null;
    'poster_url'?: string | null;
    'release_date'?: string | null;
    'title': string;
    'video_url'?: string | null;
}
export interface WrapperNewPerson {
    'bio'?: string | null;
    'birth_date'?: string | null;
    'first_name': string;
    'image_url'?: string | null;
    'last_name': string;
    'role'?: string | null;
}
export interface WrapperNewReview {
    'body'?: string | null;
    'movie_id': string;
    'rating': number;
    'title'?: string | null;
    'user_id': string;
    'user_name': string;
}
export interface WrapperPerson {
    'bio'?: string | null;
    'birth_date'?: string | null;
    'created_at': string;
    'first_name': string;
    'id': string;
    'image_url'?: string | null;
    'last_name': string;
    'role'?: string | null;
}
export interface WrapperReview {
    'body'?: string | null;
    'created_at': string;
    'id': string;
    'movie_id': string;
    'rating': number;
    'title'?: string | null;
    'user_id': string;
    'user_name': string;
}

/**
 * GenresApi - axios parameter creator
 */
export const GenresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {WrapperNewGenre} wrapperNewGenre 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGenre: async (wrapperNewGenre: WrapperNewGenre, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wrapperNewGenre' is not null or undefined
            assertParamExists('createGenre', 'wrapperNewGenre', wrapperNewGenre)
            const localVarPath = `/genres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wrapperNewGenre, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} genreId ID of the genre to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGenre: async (genreId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'genreId' is not null or undefined
            assertParamExists('deleteGenre', 'genreId', genreId)
            const localVarPath = `/genres/{genre_id}`
                .replace(`{${"genre_id"}}`, encodeURIComponent(String(genreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} genreId ID of the genre to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenreById: async (genreId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'genreId' is not null or undefined
            assertParamExists('getGenreById', 'genreId', genreId)
            const localVarPath = `/genres/{genre_id}`
                .replace(`{${"genre_id"}}`, encodeURIComponent(String(genreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} limit Max number of genres to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGenres: async (limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('listGenres', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('listGenres', 'offset', offset)
            const localVarPath = `/genres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} genreId ID of the genre to update
         * @param {WrapperNewGenre} wrapperNewGenre 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGenre: async (genreId: string, wrapperNewGenre: WrapperNewGenre, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'genreId' is not null or undefined
            assertParamExists('updateGenre', 'genreId', genreId)
            // verify required parameter 'wrapperNewGenre' is not null or undefined
            assertParamExists('updateGenre', 'wrapperNewGenre', wrapperNewGenre)
            const localVarPath = `/genres/{genre_id}`
                .replace(`{${"genre_id"}}`, encodeURIComponent(String(genreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wrapperNewGenre, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenresApi - functional programming interface
 */
export const GenresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GenresApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {WrapperNewGenre} wrapperNewGenre 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGenre(wrapperNewGenre: WrapperNewGenre, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperGenre>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGenre(wrapperNewGenre, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenresApi.createGenre']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} genreId ID of the genre to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGenre(genreId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGenre(genreId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenresApi.deleteGenre']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} genreId ID of the genre to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenreById(genreId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperGenre>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGenreById(genreId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenresApi.getGenreById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} limit Max number of genres to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGenres(limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WrapperGenre>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGenres(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenresApi.listGenres']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} genreId ID of the genre to update
         * @param {WrapperNewGenre} wrapperNewGenre 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGenre(genreId: string, wrapperNewGenre: WrapperNewGenre, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperGenre>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGenre(genreId, wrapperNewGenre, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GenresApi.updateGenre']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GenresApi - factory interface
 */
export const GenresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GenresApiFp(configuration)
    return {
        /**
         * 
         * @param {WrapperNewGenre} wrapperNewGenre 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGenre(wrapperNewGenre: WrapperNewGenre, options?: RawAxiosRequestConfig): AxiosPromise<WrapperGenre> {
            return localVarFp.createGenre(wrapperNewGenre, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} genreId ID of the genre to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGenre(genreId: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteGenre(genreId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} genreId ID of the genre to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenreById(genreId: string, options?: RawAxiosRequestConfig): AxiosPromise<WrapperGenre> {
            return localVarFp.getGenreById(genreId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} limit Max number of genres to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGenres(limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WrapperGenre>> {
            return localVarFp.listGenres(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} genreId ID of the genre to update
         * @param {WrapperNewGenre} wrapperNewGenre 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGenre(genreId: string, wrapperNewGenre: WrapperNewGenre, options?: RawAxiosRequestConfig): AxiosPromise<WrapperGenre> {
            return localVarFp.updateGenre(genreId, wrapperNewGenre, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GenresApi - object-oriented interface
 */
export class GenresApi extends BaseAPI {
    /**
     * 
     * @param {WrapperNewGenre} wrapperNewGenre 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createGenre(wrapperNewGenre: WrapperNewGenre, options?: RawAxiosRequestConfig) {
        return GenresApiFp(this.configuration).createGenre(wrapperNewGenre, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} genreId ID of the genre to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteGenre(genreId: string, options?: RawAxiosRequestConfig) {
        return GenresApiFp(this.configuration).deleteGenre(genreId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} genreId ID of the genre to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGenreById(genreId: string, options?: RawAxiosRequestConfig) {
        return GenresApiFp(this.configuration).getGenreById(genreId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} limit Max number of genres to return
     * @param {number} offset Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listGenres(limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return GenresApiFp(this.configuration).listGenres(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} genreId ID of the genre to update
     * @param {WrapperNewGenre} wrapperNewGenre 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateGenre(genreId: string, wrapperNewGenre: WrapperNewGenre, options?: RawAxiosRequestConfig) {
        return GenresApiFp(this.configuration).updateGenre(genreId, wrapperNewGenre, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MoviesApi - axios parameter creator
 */
export const MoviesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {WrapperNewMovie} wrapperNewMovie 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMovie: async (wrapperNewMovie: WrapperNewMovie, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wrapperNewMovie' is not null or undefined
            assertParamExists('createMovie', 'wrapperNewMovie', wrapperNewMovie)
            const localVarPath = `/movies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wrapperNewMovie, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} movieId ID of the movie to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMovie: async (movieId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'movieId' is not null or undefined
            assertParamExists('deleteMovie', 'movieId', movieId)
            const localVarPath = `/movies/{movie_id}`
                .replace(`{${"movie_id"}}`, encodeURIComponent(String(movieId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} limit Max number of movies to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMovies: async (limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getAllMovies', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getAllMovies', 'offset', offset)
            const localVarPath = `/movies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} movieId ID of the movie to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieById: async (movieId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'movieId' is not null or undefined
            assertParamExists('getMovieById', 'movieId', movieId)
            const localVarPath = `/movies/{movie_id}`
                .replace(`{${"movie_id"}}`, encodeURIComponent(String(movieId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} movieId ID of the movie to retrieve details for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieDetailsById: async (movieId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'movieId' is not null or undefined
            assertParamExists('getMovieDetailsById', 'movieId', movieId)
            const localVarPath = `/movies/{movie_id}/details`
                .replace(`{${"movie_id"}}`, encodeURIComponent(String(movieId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} actorName Actor name to search for movies
         * @param {number} limit Max number of movies to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMoviesByActor: async (actorName: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actorName' is not null or undefined
            assertParamExists('searchMoviesByActor', 'actorName', actorName)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('searchMoviesByActor', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('searchMoviesByActor', 'offset', offset)
            const localVarPath = `/search/movies/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (actorName !== undefined) {
                localVarQueryParameter['actor_name'] = actorName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} titleName Title query string to search for movies
         * @param {number} limit Max number of movies to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMoviesByTitle: async (titleName: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'titleName' is not null or undefined
            assertParamExists('searchMoviesByTitle', 'titleName', titleName)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('searchMoviesByTitle', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('searchMoviesByTitle', 'offset', offset)
            const localVarPath = `/search/movies/title`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (titleName !== undefined) {
                localVarQueryParameter['title_name'] = titleName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} movieId ID of the movie to update
         * @param {WrapperNewMovie} wrapperNewMovie 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMovie: async (movieId: string, wrapperNewMovie: WrapperNewMovie, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'movieId' is not null or undefined
            assertParamExists('updateMovie', 'movieId', movieId)
            // verify required parameter 'wrapperNewMovie' is not null or undefined
            assertParamExists('updateMovie', 'wrapperNewMovie', wrapperNewMovie)
            const localVarPath = `/movies/{movie_id}`
                .replace(`{${"movie_id"}}`, encodeURIComponent(String(movieId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wrapperNewMovie, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MoviesApi - functional programming interface
 */
export const MoviesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MoviesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {WrapperNewMovie} wrapperNewMovie 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMovie(wrapperNewMovie: WrapperNewMovie, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperMovie>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMovie(wrapperNewMovie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoviesApi.createMovie']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} movieId ID of the movie to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMovie(movieId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMovie(movieId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoviesApi.deleteMovie']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} limit Max number of movies to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMovies(limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WrapperMovie>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMovies(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoviesApi.getAllMovies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} movieId ID of the movie to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMovieById(movieId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperMovie>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMovieById(movieId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoviesApi.getMovieById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} movieId ID of the movie to retrieve details for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMovieDetailsById(movieId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperMovieDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMovieDetailsById(movieId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoviesApi.getMovieDetailsById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} actorName Actor name to search for movies
         * @param {number} limit Max number of movies to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMoviesByActor(actorName: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WrapperMovie>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMoviesByActor(actorName, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoviesApi.searchMoviesByActor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} titleName Title query string to search for movies
         * @param {number} limit Max number of movies to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMoviesByTitle(titleName: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WrapperMovie>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMoviesByTitle(titleName, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoviesApi.searchMoviesByTitle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} movieId ID of the movie to update
         * @param {WrapperNewMovie} wrapperNewMovie 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMovie(movieId: string, wrapperNewMovie: WrapperNewMovie, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperMovie>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMovie(movieId, wrapperNewMovie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoviesApi.updateMovie']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MoviesApi - factory interface
 */
export const MoviesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MoviesApiFp(configuration)
    return {
        /**
         * 
         * @param {WrapperNewMovie} wrapperNewMovie 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMovie(wrapperNewMovie: WrapperNewMovie, options?: RawAxiosRequestConfig): AxiosPromise<WrapperMovie> {
            return localVarFp.createMovie(wrapperNewMovie, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} movieId ID of the movie to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMovie(movieId: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteMovie(movieId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} limit Max number of movies to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMovies(limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WrapperMovie>> {
            return localVarFp.getAllMovies(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} movieId ID of the movie to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieById(movieId: string, options?: RawAxiosRequestConfig): AxiosPromise<WrapperMovie> {
            return localVarFp.getMovieById(movieId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} movieId ID of the movie to retrieve details for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieDetailsById(movieId: string, options?: RawAxiosRequestConfig): AxiosPromise<WrapperMovieDetail> {
            return localVarFp.getMovieDetailsById(movieId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} actorName Actor name to search for movies
         * @param {number} limit Max number of movies to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMoviesByActor(actorName: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WrapperMovie>> {
            return localVarFp.searchMoviesByActor(actorName, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} titleName Title query string to search for movies
         * @param {number} limit Max number of movies to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMoviesByTitle(titleName: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WrapperMovie>> {
            return localVarFp.searchMoviesByTitle(titleName, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} movieId ID of the movie to update
         * @param {WrapperNewMovie} wrapperNewMovie 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMovie(movieId: string, wrapperNewMovie: WrapperNewMovie, options?: RawAxiosRequestConfig): AxiosPromise<WrapperMovie> {
            return localVarFp.updateMovie(movieId, wrapperNewMovie, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MoviesApi - object-oriented interface
 */
export class MoviesApi extends BaseAPI {
    /**
     * 
     * @param {WrapperNewMovie} wrapperNewMovie 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createMovie(wrapperNewMovie: WrapperNewMovie, options?: RawAxiosRequestConfig) {
        return MoviesApiFp(this.configuration).createMovie(wrapperNewMovie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} movieId ID of the movie to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteMovie(movieId: string, options?: RawAxiosRequestConfig) {
        return MoviesApiFp(this.configuration).deleteMovie(movieId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} limit Max number of movies to return
     * @param {number} offset Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllMovies(limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return MoviesApiFp(this.configuration).getAllMovies(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} movieId ID of the movie to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMovieById(movieId: string, options?: RawAxiosRequestConfig) {
        return MoviesApiFp(this.configuration).getMovieById(movieId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} movieId ID of the movie to retrieve details for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMovieDetailsById(movieId: string, options?: RawAxiosRequestConfig) {
        return MoviesApiFp(this.configuration).getMovieDetailsById(movieId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} actorName Actor name to search for movies
     * @param {number} limit Max number of movies to return
     * @param {number} offset Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchMoviesByActor(actorName: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return MoviesApiFp(this.configuration).searchMoviesByActor(actorName, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} titleName Title query string to search for movies
     * @param {number} limit Max number of movies to return
     * @param {number} offset Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchMoviesByTitle(titleName: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return MoviesApiFp(this.configuration).searchMoviesByTitle(titleName, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} movieId ID of the movie to update
     * @param {WrapperNewMovie} wrapperNewMovie 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateMovie(movieId: string, wrapperNewMovie: WrapperNewMovie, options?: RawAxiosRequestConfig) {
        return MoviesApiFp(this.configuration).updateMovie(movieId, wrapperNewMovie, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PeopleApi - axios parameter creator
 */
export const PeopleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {WrapperNewPerson} wrapperNewPerson 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson: async (wrapperNewPerson: WrapperNewPerson, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wrapperNewPerson' is not null or undefined
            assertParamExists('createPerson', 'wrapperNewPerson', wrapperNewPerson)
            const localVarPath = `/people`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wrapperNewPerson, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId ID of the person to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson: async (personId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('deletePerson', 'personId', personId)
            const localVarPath = `/people/{person_id}`
                .replace(`{${"person_id"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPeople: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/people`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId ID of the person to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonById: async (personId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('getPersonById', 'personId', personId)
            const localVarPath = `/people/{person_id}`
                .replace(`{${"person_id"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} movieId ID of the movie to get people for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonByMovieId: async (movieId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'movieId' is not null or undefined
            assertParamExists('getPersonByMovieId', 'movieId', movieId)
            const localVarPath = `/people/movie/{movie_id}`
                .replace(`{${"movie_id"}}`, encodeURIComponent(String(movieId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name Name of the person to search for
         * @param {number} limit Max number of people to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonByName: async (name: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getPersonByName', 'name', name)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getPersonByName', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getPersonByName', 'offset', offset)
            const localVarPath = `/search/people/name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} personId ID of the person to update
         * @param {WrapperNewPerson} wrapperNewPerson 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson: async (personId: string, wrapperNewPerson: WrapperNewPerson, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personId' is not null or undefined
            assertParamExists('updatePerson', 'personId', personId)
            // verify required parameter 'wrapperNewPerson' is not null or undefined
            assertParamExists('updatePerson', 'wrapperNewPerson', wrapperNewPerson)
            const localVarPath = `/people/{person_id}`
                .replace(`{${"person_id"}}`, encodeURIComponent(String(personId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wrapperNewPerson, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeopleApi - functional programming interface
 */
export const PeopleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeopleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {WrapperNewPerson} wrapperNewPerson 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPerson(wrapperNewPerson: WrapperNewPerson, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperPerson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPerson(wrapperNewPerson, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.createPerson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} personId ID of the person to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePerson(personId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePerson(personId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.deletePerson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPeople(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WrapperPerson>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPeople(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.getAllPeople']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} personId ID of the person to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonById(personId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperPerson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonById(personId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.getPersonById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} movieId ID of the movie to get people for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonByMovieId(movieId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WrapperPerson>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonByMovieId(movieId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.getPersonByMovieId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name Name of the person to search for
         * @param {number} limit Max number of people to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonByName(name: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WrapperPerson>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonByName(name, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.getPersonByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} personId ID of the person to update
         * @param {WrapperNewPerson} wrapperNewPerson 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePerson(personId: string, wrapperNewPerson: WrapperNewPerson, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperPerson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePerson(personId, wrapperNewPerson, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeopleApi.updatePerson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeopleApi - factory interface
 */
export const PeopleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeopleApiFp(configuration)
    return {
        /**
         * 
         * @param {WrapperNewPerson} wrapperNewPerson 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson(wrapperNewPerson: WrapperNewPerson, options?: RawAxiosRequestConfig): AxiosPromise<WrapperPerson> {
            return localVarFp.createPerson(wrapperNewPerson, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId ID of the person to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson(personId: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deletePerson(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPeople(options?: RawAxiosRequestConfig): AxiosPromise<Array<WrapperPerson>> {
            return localVarFp.getAllPeople(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId ID of the person to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonById(personId: string, options?: RawAxiosRequestConfig): AxiosPromise<WrapperPerson> {
            return localVarFp.getPersonById(personId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} movieId ID of the movie to get people for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonByMovieId(movieId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<WrapperPerson>> {
            return localVarFp.getPersonByMovieId(movieId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name Name of the person to search for
         * @param {number} limit Max number of people to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonByName(name: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WrapperPerson>> {
            return localVarFp.getPersonByName(name, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} personId ID of the person to update
         * @param {WrapperNewPerson} wrapperNewPerson 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(personId: string, wrapperNewPerson: WrapperNewPerson, options?: RawAxiosRequestConfig): AxiosPromise<WrapperPerson> {
            return localVarFp.updatePerson(personId, wrapperNewPerson, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeopleApi - object-oriented interface
 */
export class PeopleApi extends BaseAPI {
    /**
     * 
     * @param {WrapperNewPerson} wrapperNewPerson 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPerson(wrapperNewPerson: WrapperNewPerson, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).createPerson(wrapperNewPerson, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId ID of the person to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePerson(personId: string, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).deletePerson(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllPeople(options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).getAllPeople(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId ID of the person to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPersonById(personId: string, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).getPersonById(personId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} movieId ID of the movie to get people for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPersonByMovieId(movieId: string, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).getPersonByMovieId(movieId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name Name of the person to search for
     * @param {number} limit Max number of people to return
     * @param {number} offset Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPersonByName(name: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).getPersonByName(name, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} personId ID of the person to update
     * @param {WrapperNewPerson} wrapperNewPerson 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePerson(personId: string, wrapperNewPerson: WrapperNewPerson, options?: RawAxiosRequestConfig) {
        return PeopleApiFp(this.configuration).updatePerson(personId, wrapperNewPerson, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReviewsApi - axios parameter creator
 */
export const ReviewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {WrapperNewReview} wrapperNewReview 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReview: async (wrapperNewReview: WrapperNewReview, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wrapperNewReview' is not null or undefined
            assertParamExists('createReview', 'wrapperNewReview', wrapperNewReview)
            const localVarPath = `/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wrapperNewReview, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} reviewId ID of the review to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReview: async (reviewId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewId' is not null or undefined
            assertParamExists('deleteReview', 'reviewId', reviewId)
            const localVarPath = `/reviews/{review_id}`
                .replace(`{${"review_id"}}`, encodeURIComponent(String(reviewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] Max number of reviews to return
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReviews: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} reviewId ID of the review to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewById: async (reviewId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewId' is not null or undefined
            assertParamExists('getReviewById', 'reviewId', reviewId)
            const localVarPath = `/reviews/{review_id}`
                .replace(`{${"review_id"}}`, encodeURIComponent(String(reviewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} movieId ID of the movie to get reviews for
         * @param {number} limit Max number of reviews to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsByMovieId: async (movieId: number, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'movieId' is not null or undefined
            assertParamExists('getReviewsByMovieId', 'movieId', movieId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getReviewsByMovieId', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getReviewsByMovieId', 'offset', offset)
            const localVarPath = `/reviews/movie/{movie_id}`
                .replace(`{${"movie_id"}}`, encodeURIComponent(String(movieId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId ID of the user to get reviews for
         * @param {number} limit Max number of reviews to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsByUserId: async (userId: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getReviewsByUserId', 'userId', userId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getReviewsByUserId', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getReviewsByUserId', 'offset', offset)
            const localVarPath = `/reviews/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} reviewId ID of the review to update
         * @param {WrapperNewReview} wrapperNewReview 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReview: async (reviewId: number, wrapperNewReview: WrapperNewReview, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reviewId' is not null or undefined
            assertParamExists('updateReview', 'reviewId', reviewId)
            // verify required parameter 'wrapperNewReview' is not null or undefined
            assertParamExists('updateReview', 'wrapperNewReview', wrapperNewReview)
            const localVarPath = `/reviews/{review_id}`
                .replace(`{${"review_id"}}`, encodeURIComponent(String(reviewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wrapperNewReview, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewsApi - functional programming interface
 */
export const ReviewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {WrapperNewReview} wrapperNewReview 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReview(wrapperNewReview: WrapperNewReview, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReview(wrapperNewReview, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.createReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} reviewId ID of the review to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReview(reviewId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReview(reviewId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.deleteReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [limit] Max number of reviews to return
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllReviews(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WrapperReview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllReviews(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.getAllReviews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} reviewId ID of the review to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewById(reviewId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewById(reviewId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.getReviewById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} movieId ID of the movie to get reviews for
         * @param {number} limit Max number of reviews to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsByMovieId(movieId: number, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WrapperReview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsByMovieId(movieId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.getReviewsByMovieId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId ID of the user to get reviews for
         * @param {number} limit Max number of reviews to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsByUserId(userId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WrapperReview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsByUserId(userId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.getReviewsByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} reviewId ID of the review to update
         * @param {WrapperNewReview} wrapperNewReview 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReview(reviewId: number, wrapperNewReview: WrapperNewReview, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WrapperReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReview(reviewId, wrapperNewReview, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewsApi.updateReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReviewsApi - factory interface
 */
export const ReviewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewsApiFp(configuration)
    return {
        /**
         * 
         * @param {WrapperNewReview} wrapperNewReview 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReview(wrapperNewReview: WrapperNewReview, options?: RawAxiosRequestConfig): AxiosPromise<WrapperReview> {
            return localVarFp.createReview(wrapperNewReview, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} reviewId ID of the review to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReview(reviewId: number, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteReview(reviewId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] Max number of reviews to return
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReviews(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WrapperReview>> {
            return localVarFp.getAllReviews(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} reviewId ID of the review to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewById(reviewId: number, options?: RawAxiosRequestConfig): AxiosPromise<WrapperReview> {
            return localVarFp.getReviewById(reviewId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} movieId ID of the movie to get reviews for
         * @param {number} limit Max number of reviews to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsByMovieId(movieId: number, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WrapperReview>> {
            return localVarFp.getReviewsByMovieId(movieId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId ID of the user to get reviews for
         * @param {number} limit Max number of reviews to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsByUserId(userId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WrapperReview>> {
            return localVarFp.getReviewsByUserId(userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} reviewId ID of the review to update
         * @param {WrapperNewReview} wrapperNewReview 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReview(reviewId: number, wrapperNewReview: WrapperNewReview, options?: RawAxiosRequestConfig): AxiosPromise<WrapperReview> {
            return localVarFp.updateReview(reviewId, wrapperNewReview, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReviewsApi - object-oriented interface
 */
export class ReviewsApi extends BaseAPI {
    /**
     * 
     * @param {WrapperNewReview} wrapperNewReview 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createReview(wrapperNewReview: WrapperNewReview, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).createReview(wrapperNewReview, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} reviewId ID of the review to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteReview(reviewId: number, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).deleteReview(reviewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] Max number of reviews to return
     * @param {number} [offset] Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllReviews(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).getAllReviews(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} reviewId ID of the review to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getReviewById(reviewId: number, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).getReviewById(reviewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} movieId ID of the movie to get reviews for
     * @param {number} limit Max number of reviews to return
     * @param {number} offset Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getReviewsByMovieId(movieId: number, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).getReviewsByMovieId(movieId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId ID of the user to get reviews for
     * @param {number} limit Max number of reviews to return
     * @param {number} offset Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getReviewsByUserId(userId: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).getReviewsByUserId(userId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} reviewId ID of the review to update
     * @param {WrapperNewReview} wrapperNewReview 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateReview(reviewId: number, wrapperNewReview: WrapperNewReview, options?: RawAxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).updateReview(reviewId, wrapperNewReview, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadsApi - axios parameter creator
 */
export const UploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UploadSasRequest} uploadSasRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestUploadSas: async (uploadSasRequest: UploadSasRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadSasRequest' is not null or undefined
            assertParamExists('requestUploadSas', 'uploadSasRequest', uploadSasRequest)
            const localVarPath = `/uploads/request-sas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadSasRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsApi - functional programming interface
 */
export const UploadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UploadSasRequest} uploadSasRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestUploadSas(uploadSasRequest: UploadSasRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadSasResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestUploadSas(uploadSasRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadsApi.requestUploadSas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadsApi - factory interface
 */
export const UploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadsApiFp(configuration)
    return {
        /**
         * 
         * @param {UploadSasRequest} uploadSasRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestUploadSas(uploadSasRequest: UploadSasRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadSasResponse> {
            return localVarFp.requestUploadSas(uploadSasRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadsApi - object-oriented interface
 */
export class UploadsApi extends BaseAPI {
    /**
     * 
     * @param {UploadSasRequest} uploadSasRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public requestUploadSas(uploadSasRequest: UploadSasRequest, options?: RawAxiosRequestConfig) {
        return UploadsApiFp(this.configuration).requestUploadSas(uploadSasRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewUser} newUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (newUser: NewUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newUser' is not null or undefined
            assertParamExists('createUser', 'newUser', newUser)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId UUID of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId UUID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId UUID of the user to update
         * @param {UpdateUser} updateUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, updateUser: UpdateUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            // verify required parameter 'updateUser' is not null or undefined
            assertParamExists('updateUser', 'updateUser', updateUser)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {NewUser} newUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(newUser: NewUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(newUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId UUID of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId UUID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId UUID of the user to update
         * @param {UpdateUser} updateUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, updateUser: UpdateUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, updateUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {NewUser} newUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(newUser: NewUser, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createUser(newUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId UUID of the user to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.getAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId UUID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId UUID of the user to update
         * @param {UpdateUser} updateUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, updateUser: UpdateUser, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(userId, updateUser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {NewUser} newUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUser(newUser: NewUser, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(newUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId UUID of the user to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUser(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllUsers(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId UUID of the user to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserById(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId UUID of the user to update
     * @param {UpdateUser} updateUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUser(userId: string, updateUser: UpdateUser, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(userId, updateUser, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WatchHistoryApi - axios parameter creator
 */
export const WatchHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewWatchHistory} newWatchHistory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchHistory: async (newWatchHistory: NewWatchHistory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newWatchHistory' is not null or undefined
            assertParamExists('createWatchHistory', 'newWatchHistory', newWatchHistory)
            const localVarPath = `/watch-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newWatchHistory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id ID of the watch history entry to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchHistory: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWatchHistory', 'id', id)
            const localVarPath = `/watch-history/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id ID of the watch history entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchHistoryById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWatchHistoryById', 'id', id)
            const localVarPath = `/watch-history/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId UUID of the user whose history to retrieve
         * @param {number} limit Max number of items to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchHistoryByUser: async (userId: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listWatchHistoryByUser', 'userId', userId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('listWatchHistoryByUser', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('listWatchHistoryByUser', 'offset', offset)
            const localVarPath = `/users/{user_id}/watch-history`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id ID of the watch history entry to update
         * @param {UpdateWatchHistory} updateWatchHistory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchHistory: async (id: number, updateWatchHistory: UpdateWatchHistory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWatchHistory', 'id', id)
            // verify required parameter 'updateWatchHistory' is not null or undefined
            assertParamExists('updateWatchHistory', 'updateWatchHistory', updateWatchHistory)
            const localVarPath = `/watch-history/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWatchHistory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WatchHistoryApi - functional programming interface
 */
export const WatchHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WatchHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {NewWatchHistory} newWatchHistory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWatchHistory(newWatchHistory: NewWatchHistory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWatchHistory(newWatchHistory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchHistoryApi.createWatchHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id ID of the watch history entry to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWatchHistory(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWatchHistory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchHistoryApi.deleteWatchHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id ID of the watch history entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWatchHistoryById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWatchHistoryById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchHistoryApi.getWatchHistoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId UUID of the user whose history to retrieve
         * @param {number} limit Max number of items to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWatchHistoryByUser(userId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WatchHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWatchHistoryByUser(userId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchHistoryApi.listWatchHistoryByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id ID of the watch history entry to update
         * @param {UpdateWatchHistory} updateWatchHistory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWatchHistory(id: number, updateWatchHistory: UpdateWatchHistory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWatchHistory(id, updateWatchHistory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchHistoryApi.updateWatchHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WatchHistoryApi - factory interface
 */
export const WatchHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WatchHistoryApiFp(configuration)
    return {
        /**
         * 
         * @param {NewWatchHistory} newWatchHistory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchHistory(newWatchHistory: NewWatchHistory, options?: RawAxiosRequestConfig): AxiosPromise<WatchHistory> {
            return localVarFp.createWatchHistory(newWatchHistory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id ID of the watch history entry to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchHistory(id: number, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteWatchHistory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id ID of the watch history entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchHistoryById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<WatchHistory> {
            return localVarFp.getWatchHistoryById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId UUID of the user whose history to retrieve
         * @param {number} limit Max number of items to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchHistoryByUser(userId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WatchHistory>> {
            return localVarFp.listWatchHistoryByUser(userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id ID of the watch history entry to update
         * @param {UpdateWatchHistory} updateWatchHistory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchHistory(id: number, updateWatchHistory: UpdateWatchHistory, options?: RawAxiosRequestConfig): AxiosPromise<WatchHistory> {
            return localVarFp.updateWatchHistory(id, updateWatchHistory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WatchHistoryApi - object-oriented interface
 */
export class WatchHistoryApi extends BaseAPI {
    /**
     * 
     * @param {NewWatchHistory} newWatchHistory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWatchHistory(newWatchHistory: NewWatchHistory, options?: RawAxiosRequestConfig) {
        return WatchHistoryApiFp(this.configuration).createWatchHistory(newWatchHistory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id ID of the watch history entry to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWatchHistory(id: number, options?: RawAxiosRequestConfig) {
        return WatchHistoryApiFp(this.configuration).deleteWatchHistory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id ID of the watch history entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWatchHistoryById(id: number, options?: RawAxiosRequestConfig) {
        return WatchHistoryApiFp(this.configuration).getWatchHistoryById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId UUID of the user whose history to retrieve
     * @param {number} limit Max number of items to return
     * @param {number} offset Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listWatchHistoryByUser(userId: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return WatchHistoryApiFp(this.configuration).listWatchHistoryByUser(userId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id ID of the watch history entry to update
     * @param {UpdateWatchHistory} updateWatchHistory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateWatchHistory(id: number, updateWatchHistory: UpdateWatchHistory, options?: RawAxiosRequestConfig) {
        return WatchHistoryApiFp(this.configuration).updateWatchHistory(id, updateWatchHistory, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WatchRoomMessagesApi - axios parameter creator
 */
export const WatchRoomMessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewWatchRoomMessage} newWatchRoomMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchRoomMessage: async (newWatchRoomMessage: NewWatchRoomMessage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newWatchRoomMessage' is not null or undefined
            assertParamExists('createWatchRoomMessage', 'newWatchRoomMessage', newWatchRoomMessage)
            const localVarPath = `/watch-room-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newWatchRoomMessage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomId UUID of the room whose messages to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessagesByRoom: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('deleteMessagesByRoom', 'roomId', roomId)
            const localVarPath = `/watch-rooms/{room_id}/messages`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} messageId ID of the message to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchRoomMessage: async (messageId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteWatchRoomMessage', 'messageId', messageId)
            const localVarPath = `/watch-room-messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} messageId ID of the message to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchRoomMessageById: async (messageId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getWatchRoomMessageById', 'messageId', messageId)
            const localVarPath = `/watch-room-messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomId UUID of the room whose messages to retrieve
         * @param {number} limit Max number of messages
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessagesByRoom: async (roomId: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('listMessagesByRoom', 'roomId', roomId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('listMessagesByRoom', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('listMessagesByRoom', 'offset', offset)
            const localVarPath = `/watch-rooms/{room_id}/messages`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WatchRoomMessagesApi - functional programming interface
 */
export const WatchRoomMessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WatchRoomMessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {NewWatchRoomMessage} newWatchRoomMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWatchRoomMessage(newWatchRoomMessage: NewWatchRoomMessage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchRoomMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWatchRoomMessage(newWatchRoomMessage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomMessagesApi.createWatchRoomMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roomId UUID of the room whose messages to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessagesByRoom(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessagesByRoom(roomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomMessagesApi.deleteMessagesByRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} messageId ID of the message to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWatchRoomMessage(messageId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWatchRoomMessage(messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomMessagesApi.deleteWatchRoomMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} messageId ID of the message to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWatchRoomMessageById(messageId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchRoomMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWatchRoomMessageById(messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomMessagesApi.getWatchRoomMessageById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roomId UUID of the room whose messages to retrieve
         * @param {number} limit Max number of messages
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMessagesByRoom(roomId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WatchRoomMessage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMessagesByRoom(roomId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomMessagesApi.listMessagesByRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WatchRoomMessagesApi - factory interface
 */
export const WatchRoomMessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WatchRoomMessagesApiFp(configuration)
    return {
        /**
         * 
         * @param {NewWatchRoomMessage} newWatchRoomMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchRoomMessage(newWatchRoomMessage: NewWatchRoomMessage, options?: RawAxiosRequestConfig): AxiosPromise<WatchRoomMessage> {
            return localVarFp.createWatchRoomMessage(newWatchRoomMessage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomId UUID of the room whose messages to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessagesByRoom(roomId: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteMessagesByRoom(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} messageId ID of the message to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchRoomMessage(messageId: number, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteWatchRoomMessage(messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} messageId ID of the message to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchRoomMessageById(messageId: number, options?: RawAxiosRequestConfig): AxiosPromise<WatchRoomMessage> {
            return localVarFp.getWatchRoomMessageById(messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomId UUID of the room whose messages to retrieve
         * @param {number} limit Max number of messages
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessagesByRoom(roomId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WatchRoomMessage>> {
            return localVarFp.listMessagesByRoom(roomId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WatchRoomMessagesApi - object-oriented interface
 */
export class WatchRoomMessagesApi extends BaseAPI {
    /**
     * 
     * @param {NewWatchRoomMessage} newWatchRoomMessage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWatchRoomMessage(newWatchRoomMessage: NewWatchRoomMessage, options?: RawAxiosRequestConfig) {
        return WatchRoomMessagesApiFp(this.configuration).createWatchRoomMessage(newWatchRoomMessage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomId UUID of the room whose messages to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteMessagesByRoom(roomId: string, options?: RawAxiosRequestConfig) {
        return WatchRoomMessagesApiFp(this.configuration).deleteMessagesByRoom(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} messageId ID of the message to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWatchRoomMessage(messageId: number, options?: RawAxiosRequestConfig) {
        return WatchRoomMessagesApiFp(this.configuration).deleteWatchRoomMessage(messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} messageId ID of the message to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWatchRoomMessageById(messageId: number, options?: RawAxiosRequestConfig) {
        return WatchRoomMessagesApiFp(this.configuration).getWatchRoomMessageById(messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomId UUID of the room whose messages to retrieve
     * @param {number} limit Max number of messages
     * @param {number} offset Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMessagesByRoom(roomId: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return WatchRoomMessagesApiFp(this.configuration).listMessagesByRoom(roomId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WatchRoomParticipantsApi - axios parameter creator
 */
export const WatchRoomParticipantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewWatchRoomParticipant} newWatchRoomParticipant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchRoomParticipant: async (newWatchRoomParticipant: NewWatchRoomParticipant, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newWatchRoomParticipant' is not null or undefined
            assertParamExists('createWatchRoomParticipant', 'newWatchRoomParticipant', newWatchRoomParticipant)
            const localVarPath = `/watch-room-participants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newWatchRoomParticipant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomId UUID of the room whose participants to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParticipantsByRoom: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('deleteParticipantsByRoom', 'roomId', roomId)
            const localVarPath = `/watch-rooms/{room_id}/participants`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomId UUID of the room
         * @param {string} userId UUID of the participant to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchRoomParticipant: async (roomId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('deleteWatchRoomParticipant', 'roomId', roomId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteWatchRoomParticipant', 'userId', userId)
            const localVarPath = `/watch-rooms/{room_id}/participants/{user_id}`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} participantId ID of the participant to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchRoomParticipantById: async (participantId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('getWatchRoomParticipantById', 'participantId', participantId)
            const localVarPath = `/watch-room-participants/{participant_id}`
                .replace(`{${"participant_id"}}`, encodeURIComponent(String(participantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomId UUID of the room whose participants to retrieve
         * @param {number} limit Max number of participants
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listParticipantsByRoom: async (roomId: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('listParticipantsByRoom', 'roomId', roomId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('listParticipantsByRoom', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('listParticipantsByRoom', 'offset', offset)
            const localVarPath = `/watch-rooms/{room_id}/participants`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WatchRoomParticipantsApi - functional programming interface
 */
export const WatchRoomParticipantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WatchRoomParticipantsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {NewWatchRoomParticipant} newWatchRoomParticipant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWatchRoomParticipant(newWatchRoomParticipant: NewWatchRoomParticipant, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchRoomParticipant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWatchRoomParticipant(newWatchRoomParticipant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomParticipantsApi.createWatchRoomParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roomId UUID of the room whose participants to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteParticipantsByRoom(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteParticipantsByRoom(roomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomParticipantsApi.deleteParticipantsByRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roomId UUID of the room
         * @param {string} userId UUID of the participant to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWatchRoomParticipant(roomId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWatchRoomParticipant(roomId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomParticipantsApi.deleteWatchRoomParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} participantId ID of the participant to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWatchRoomParticipantById(participantId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchRoomParticipant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWatchRoomParticipantById(participantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomParticipantsApi.getWatchRoomParticipantById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roomId UUID of the room whose participants to retrieve
         * @param {number} limit Max number of participants
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listParticipantsByRoom(roomId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WatchRoomParticipant>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listParticipantsByRoom(roomId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomParticipantsApi.listParticipantsByRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WatchRoomParticipantsApi - factory interface
 */
export const WatchRoomParticipantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WatchRoomParticipantsApiFp(configuration)
    return {
        /**
         * 
         * @param {NewWatchRoomParticipant} newWatchRoomParticipant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchRoomParticipant(newWatchRoomParticipant: NewWatchRoomParticipant, options?: RawAxiosRequestConfig): AxiosPromise<WatchRoomParticipant> {
            return localVarFp.createWatchRoomParticipant(newWatchRoomParticipant, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomId UUID of the room whose participants to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParticipantsByRoom(roomId: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteParticipantsByRoom(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomId UUID of the room
         * @param {string} userId UUID of the participant to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchRoomParticipant(roomId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteWatchRoomParticipant(roomId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} participantId ID of the participant to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchRoomParticipantById(participantId: number, options?: RawAxiosRequestConfig): AxiosPromise<WatchRoomParticipant> {
            return localVarFp.getWatchRoomParticipantById(participantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomId UUID of the room whose participants to retrieve
         * @param {number} limit Max number of participants
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listParticipantsByRoom(roomId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WatchRoomParticipant>> {
            return localVarFp.listParticipantsByRoom(roomId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WatchRoomParticipantsApi - object-oriented interface
 */
export class WatchRoomParticipantsApi extends BaseAPI {
    /**
     * 
     * @param {NewWatchRoomParticipant} newWatchRoomParticipant 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWatchRoomParticipant(newWatchRoomParticipant: NewWatchRoomParticipant, options?: RawAxiosRequestConfig) {
        return WatchRoomParticipantsApiFp(this.configuration).createWatchRoomParticipant(newWatchRoomParticipant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomId UUID of the room whose participants to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteParticipantsByRoom(roomId: string, options?: RawAxiosRequestConfig) {
        return WatchRoomParticipantsApiFp(this.configuration).deleteParticipantsByRoom(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomId UUID of the room
     * @param {string} userId UUID of the participant to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWatchRoomParticipant(roomId: string, userId: string, options?: RawAxiosRequestConfig) {
        return WatchRoomParticipantsApiFp(this.configuration).deleteWatchRoomParticipant(roomId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} participantId ID of the participant to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWatchRoomParticipantById(participantId: number, options?: RawAxiosRequestConfig) {
        return WatchRoomParticipantsApiFp(this.configuration).getWatchRoomParticipantById(participantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomId UUID of the room whose participants to retrieve
     * @param {number} limit Max number of participants
     * @param {number} offset Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listParticipantsByRoom(roomId: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return WatchRoomParticipantsApiFp(this.configuration).listParticipantsByRoom(roomId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WatchRoomsApi - axios parameter creator
 */
export const WatchRoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} roomId UUID of the room to connect to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectRoom: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('connectRoom', 'roomId', roomId)
            const localVarPath = `/watch-rooms/{room_id}/connect`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NewWatchRoom} newWatchRoom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchRoom: async (newWatchRoom: NewWatchRoom, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newWatchRoom' is not null or undefined
            assertParamExists('createWatchRoom', 'newWatchRoom', newWatchRoom)
            const localVarPath = `/watch-rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newWatchRoom, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomId UUID of the room to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchRoom: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('deleteWatchRoom', 'roomId', roomId)
            const localVarPath = `/watch-rooms/{room_id}`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomId UUID of the watch room to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchRoomById: async (roomId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getWatchRoomById', 'roomId', roomId)
            const localVarPath = `/watch-rooms/{room_id}`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hostUserId UUID of the user hosting the rooms
         * @param {number} limit Max number of rooms to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomsByHost: async (hostUserId: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostUserId' is not null or undefined
            assertParamExists('listRoomsByHost', 'hostUserId', hostUserId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('listRoomsByHost', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('listRoomsByHost', 'offset', offset)
            const localVarPath = `/users/{host_user_id}/watch-rooms`
                .replace(`{${"host_user_id"}}`, encodeURIComponent(String(hostUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomId UUID of the room to update
         * @param {UpdateWatchRoom} updateWatchRoom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchRoom: async (roomId: string, updateWatchRoom: UpdateWatchRoom, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('updateWatchRoom', 'roomId', roomId)
            // verify required parameter 'updateWatchRoom' is not null or undefined
            assertParamExists('updateWatchRoom', 'updateWatchRoom', updateWatchRoom)
            const localVarPath = `/watch-rooms/{room_id}`
                .replace(`{${"room_id"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWatchRoom, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WatchRoomsApi - functional programming interface
 */
export const WatchRoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WatchRoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} roomId UUID of the room to connect to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectRoom(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectRoom(roomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomsApi.connectRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {NewWatchRoom} newWatchRoom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWatchRoom(newWatchRoom: NewWatchRoom, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWatchRoom(newWatchRoom, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomsApi.createWatchRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roomId UUID of the room to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWatchRoom(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWatchRoom(roomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomsApi.deleteWatchRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roomId UUID of the watch room to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWatchRoomById(roomId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWatchRoomById(roomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomsApi.getWatchRoomById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} hostUserId UUID of the user hosting the rooms
         * @param {number} limit Max number of rooms to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoomsByHost(hostUserId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WatchRoom>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoomsByHost(hostUserId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomsApi.listRoomsByHost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roomId UUID of the room to update
         * @param {UpdateWatchRoom} updateWatchRoom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWatchRoom(roomId: string, updateWatchRoom: UpdateWatchRoom, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchRoom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWatchRoom(roomId, updateWatchRoom, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchRoomsApi.updateWatchRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WatchRoomsApi - factory interface
 */
export const WatchRoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WatchRoomsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} roomId UUID of the room to connect to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectRoom(roomId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectRoom(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NewWatchRoom} newWatchRoom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchRoom(newWatchRoom: NewWatchRoom, options?: RawAxiosRequestConfig): AxiosPromise<WatchRoom> {
            return localVarFp.createWatchRoom(newWatchRoom, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomId UUID of the room to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchRoom(roomId: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteWatchRoom(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomId UUID of the watch room to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchRoomById(roomId: string, options?: RawAxiosRequestConfig): AxiosPromise<WatchRoom> {
            return localVarFp.getWatchRoomById(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} hostUserId UUID of the user hosting the rooms
         * @param {number} limit Max number of rooms to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomsByHost(hostUserId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WatchRoom>> {
            return localVarFp.listRoomsByHost(hostUserId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomId UUID of the room to update
         * @param {UpdateWatchRoom} updateWatchRoom 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchRoom(roomId: string, updateWatchRoom: UpdateWatchRoom, options?: RawAxiosRequestConfig): AxiosPromise<WatchRoom> {
            return localVarFp.updateWatchRoom(roomId, updateWatchRoom, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WatchRoomsApi - object-oriented interface
 */
export class WatchRoomsApi extends BaseAPI {
    /**
     * 
     * @param {string} roomId UUID of the room to connect to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectRoom(roomId: string, options?: RawAxiosRequestConfig) {
        return WatchRoomsApiFp(this.configuration).connectRoom(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NewWatchRoom} newWatchRoom 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWatchRoom(newWatchRoom: NewWatchRoom, options?: RawAxiosRequestConfig) {
        return WatchRoomsApiFp(this.configuration).createWatchRoom(newWatchRoom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomId UUID of the room to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWatchRoom(roomId: string, options?: RawAxiosRequestConfig) {
        return WatchRoomsApiFp(this.configuration).deleteWatchRoom(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomId UUID of the watch room to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWatchRoomById(roomId: string, options?: RawAxiosRequestConfig) {
        return WatchRoomsApiFp(this.configuration).getWatchRoomById(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} hostUserId UUID of the user hosting the rooms
     * @param {number} limit Max number of rooms to return
     * @param {number} offset Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listRoomsByHost(hostUserId: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return WatchRoomsApiFp(this.configuration).listRoomsByHost(hostUserId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomId UUID of the room to update
     * @param {UpdateWatchRoom} updateWatchRoom 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateWatchRoom(roomId: string, updateWatchRoom: UpdateWatchRoom, options?: RawAxiosRequestConfig) {
        return WatchRoomsApiFp(this.configuration).updateWatchRoom(roomId, updateWatchRoom, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WatchlistApi - axios parameter creator
 */
export const WatchlistApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewWatchlist} newWatchlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistItem: async (newWatchlist: NewWatchlist, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newWatchlist' is not null or undefined
            assertParamExists('createWatchlistItem', 'newWatchlist', newWatchlist)
            const localVarPath = `/watchlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newWatchlist, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId UUID of the user
         * @param {string} contentId UUID of the content item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistItem: async (userId: string, contentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteWatchlistItem', 'userId', userId)
            // verify required parameter 'contentId' is not null or undefined
            assertParamExists('deleteWatchlistItem', 'contentId', contentId)
            const localVarPath = `/users/{user_id}/watchlist/{content_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"content_id"}}`, encodeURIComponent(String(contentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId UUID of the user whose watchlist to retrieve
         * @param {number} limit Max number of items to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchlistByUser: async (userId: string, limit: number, offset: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getWatchlistByUser', 'userId', userId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getWatchlistByUser', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getWatchlistByUser', 'offset', offset)
            const localVarPath = `/users/{user_id}/watchlist`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WatchlistApi - functional programming interface
 */
export const WatchlistApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WatchlistApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {NewWatchlist} newWatchlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWatchlistItem(newWatchlist: NewWatchlist, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Watchlist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWatchlistItem(newWatchlist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchlistApi.createWatchlistItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId UUID of the user
         * @param {string} contentId UUID of the content item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWatchlistItem(userId: string, contentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWatchlistItem(userId, contentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchlistApi.deleteWatchlistItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId UUID of the user whose watchlist to retrieve
         * @param {number} limit Max number of items to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWatchlistByUser(userId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Watchlist>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWatchlistByUser(userId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WatchlistApi.getWatchlistByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WatchlistApi - factory interface
 */
export const WatchlistApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WatchlistApiFp(configuration)
    return {
        /**
         * 
         * @param {NewWatchlist} newWatchlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistItem(newWatchlist: NewWatchlist, options?: RawAxiosRequestConfig): AxiosPromise<Watchlist> {
            return localVarFp.createWatchlistItem(newWatchlist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId UUID of the user
         * @param {string} contentId UUID of the content item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistItem(userId: string, contentId: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.deleteWatchlistItem(userId, contentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId UUID of the user whose watchlist to retrieve
         * @param {number} limit Max number of items to return
         * @param {number} offset Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchlistByUser(userId: string, limit: number, offset: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Watchlist>> {
            return localVarFp.getWatchlistByUser(userId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WatchlistApi - object-oriented interface
 */
export class WatchlistApi extends BaseAPI {
    /**
     * 
     * @param {NewWatchlist} newWatchlist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWatchlistItem(newWatchlist: NewWatchlist, options?: RawAxiosRequestConfig) {
        return WatchlistApiFp(this.configuration).createWatchlistItem(newWatchlist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId UUID of the user
     * @param {string} contentId UUID of the content item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWatchlistItem(userId: string, contentId: string, options?: RawAxiosRequestConfig) {
        return WatchlistApiFp(this.configuration).deleteWatchlistItem(userId, contentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId UUID of the user whose watchlist to retrieve
     * @param {number} limit Max number of items to return
     * @param {number} offset Pagination offset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWatchlistByUser(userId: string, limit: number, offset: number, options?: RawAxiosRequestConfig) {
        return WatchlistApiFp(this.configuration).getWatchlistByUser(userId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



